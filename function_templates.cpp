#include <iostream>
#include <typeinfo>
#include <string.h> 
#include <stdio.h>
using namespace std;

/*
 * Find the max value between two numbers. 
 * MaxInt accepts two integers and returns the largest integer. 
 * If we want to use floats we would need to use MaxFloat, however this can become
 * tedious as we would need a function for each type. This is where templates come in. 
 * Templates allow us to operate with any data type. 
*/

int MaxInt(int x, int y) {
	// if condition true return x else return y 
	return x > y ? x : y ; 
}

float MaxFloat(float x, float y) {
	// if condition true return x else return y 
	return x > y ? x : y ; 
}

int AddInt( int x , int y ) {
	return x+y ; 
}

/* all templates must start with the key word template. 
 * followed by the placeholder for the types < typename some_name > 
 * the argument passed in will be deduced. 
 * If we don't invoke this function template then the function is not 
 * created/generated by the compiler. The process is called instantiation 
 * when the template is generated. 
 * Pro = no runtime costs. 
*/
template<typename T>
T Max ( T x , T y) { // argument wil be type T 
    std::cout << typeid(T).name() << std::endl; 
	return x > y ? x : y ; 
} // return type will be type T 

template<typename T>
T Add ( T x , T y) { // argument wil be type T 
	return x+y ; 
} // return type will be type T 

template char Max(char x, char y); // explicit instantiation 
//template<> const char * Max(const char *x, const char *y){ // still explicit specialisation 
template<> const char * Max<const char*>(const char *x, const char *y){ // this way is easier to spot explicit specialisation
	return strcmp(x,y) > 0 ? x : y; 
}

template< int size>
void Print() {
	//size++; // build error as can't modify a constant 
	char buffer[size]; 
	std::cout<<size<<std::endl; 
}

/*
//Requires size as explicit argument
template<typename T>
T Sum(T*parr, int size){
	T sum{};
	for (int i = 0; i < size; ++i) {
		sum += parr[i];
	}
	return sum;
}
*/

// if you don't know the size of the array 
//Size is implicitly calculated in non-type template argument
template<typename T,int size>
T Sum(T (&parr)[size]) {
	T sum{};
	for (int i = 0; i < size; ++i) {
		sum += parr[i];
	}
	return sum;
}
int main () {
	Max(3,8);  // calls template and prints the return type
	Max(3.3f, 5.8f);
	Max(static_cast<float>(3),5.3f);  // casting 
	Max<double>(3,6.2);// override
	auto num1 = MaxInt(3,8); // invoke function here 
	auto num2 = MaxFloat(3.3f, 5.8f); 
	auto num3 = Max(3,8);
	auto num4 = Max(3.3f, 5.8f);
	auto num5 = AddInt(2,2); 
	auto num6 = Add(3,5); 
	auto num7 = Add(3.3,5.1); 
	cout << "Hello World! \n";
	std::cout << num1 << std::endl; // print 
	std::cout << num2 << std::endl;
	std::cout << num3 << std::endl;
	std::cout << num4 << std::endl;
	std::cout << num5 << std::endl;
	std::cout << num6 << std::endl;
	std::cout << num7 << std::endl;
	
	/* explicit specialisation */
	// ascii values of the strings are compared 
	const char *a{"A"};
	const char *b{"B"};
	/* if you just call the original Max() then we print out the largest address not the largest ascii value. */ 
	auto s = Max(a,b); 
	std::cout<<s<<std::endl;  
	
	Print<3>(); 
	int i = 3; 
	/*  Print<i>(); // building error */
	Print<sizeof(i)>(); 
	
	int arr[]{ 3,1,9,7 };
	auto it = std::begin(arr); 
	//int (&ref)[5] = arr ; // reference of the array , 4 is the size of the array 
	//int sum = Sum(arr,4); 
	int sum = Sum(arr); // pass array in without knowing the size of array 
	std::cout<<sum<<std::endl;  
	
	return 0; 
}